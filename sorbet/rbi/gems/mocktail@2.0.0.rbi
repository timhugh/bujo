# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mocktail` gem.
# Please instead update this file by running `bin/tapioca gem mocktail`.


# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mocktail` gem.
# Please instead update this file by running `bin/tapioca gem mocktail`.

# The Cabinet stores all thread-local state, so anything that goes here
# is guaranteed by Mocktail to be local to the currently-running thread
#
# source://mocktail//lib/mocktail/sorbet/mocktail/typed.rb#3
# The Cabinet stores all thread-local state, so anything that goes here
module Mocktail
  extend ::Mocktail::DSL

  class << self
    # Stores most transactional state about calls & stubbing configurations
    # Anything returned by this is undocumented and could change at any time, so
    # don't commit code that relies on it!
    #
    # source://mocktail//lib/mocktail/sorbet/mocktail.rb#149
    # Stores most transactional state about calls & stubbing configurations
    # Anything returned by this is undocumented and could change at any time, so
    sig { returns(::Mocktail::Cabinet) }
    def cabinet; end

    # An alias for Mocktail.explain(double).reference.calls
    # Takes an optional second parameter of the method name to filter only
    # calls to that method
    #
    # source://mocktail//lib/mocktail/sorbet/mocktail.rb#141
    # An alias for Mocktail.explain(double).reference.calls
    # Takes an optional second parameter of the method name to filter only
    sig do
      params(
        double: ::Object,
        method_name: T.nilable(T.any(::String, ::Symbol))
      ).returns(T::Array[::Mocktail::Call])
    end
    def calls(double, method_name = T.unsafe(nil)); end

    # source://mocktail//lib/mocktail/sorbet/mocktail.rb#99
    sig { returns(::Mocktail::Matchers::Captor) }
    def captor; end

    # source://mocktail//lib/mocktail/sorbet/mocktail.rb#125
    sig { params(thing: ::Object).returns(::Mocktail::Explanation) }
    def explain(thing); end

    # source://mocktail//lib/mocktail/sorbet/mocktail.rb#130
    sig { returns(T::Array[::Mocktail::UnsatisfyingCallExplanation]) }
    def explain_nils; end

    # source://mocktail//lib/mocktail/sorbet/mocktail.rb#94
    sig { returns(::Mocktail::MatcherPresentation) }
    def matchers; end

    # Returns an instance of `type` whose implementation is mocked out
    #
    # source://mocktail//lib/mocktail/sorbet/mocktail.rb#52
    sig do
      type_parameters(:T)
        .params(
          type: T::Class[T.all(::Object, T.type_parameter(:T))]
        ).returns(T.all(::Object, T.type_parameter(:T)))
    end
    def of(type); end

    # Returns an instance of `klass` whose implementation is mocked out AND
    # stubs its constructor to return that fake the next time klass.new is called
    #
    # source://mocktail//lib/mocktail/sorbet/mocktail.rb#63
    # Returns an instance of `klass` whose implementation is mocked out AND
    sig do
      type_parameters(:T)
        .params(
          type: T::Class[T.all(::Object, T.type_parameter(:T))],
          count: T.nilable(::Integer)
        ).returns(T.type_parameter(:T))
    end
    def of_next(type, count: T.unsafe(nil)); end

    # An alias of of_next that always returns an array of fakes
    #
    # source://mocktail//lib/mocktail/sorbet/mocktail.rb#89
    sig do
      type_parameters(:T)
        .params(
          type: T::Class[T.all(::Object, T.type_parameter(:T))],
          count: ::Integer
        ).returns(T::Array[T.type_parameter(:T)])
    end
    def of_next_with_count(type, count); end

    # source://mocktail//lib/mocktail/sorbet/mocktail.rb#104
    sig { params(matcher: T.class_of(Mocktail::Matchers::Base)).void }
    def register_matcher(matcher); end

    # Replaces every singleton method on `type` with a fake, and when instantiated
    # or included will also fake instance methods
    #
    # source://mocktail//lib/mocktail/sorbet/mocktail.rb#111
    # Replaces every singleton method on `type` with a fake, and when instantiated
    sig { params(type: T.any(::Module, T::Class[T.anything])).void }
    def replace(type); end

    # source://mocktail//lib/mocktail/sorbet/mocktail.rb#117
    sig { void }
    def reset; end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/errors.rb#12
class Mocktail::AmbiguousDemonstrationError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/sorbet/mocktail.rb#44
Mocktail::BASE_PATH = T.let(T.unsafe(nil), String)

# source://mocktail//lib/mocktail/sorbet/mocktail/share/bind.rb#4
module Mocktail::Bind
  class << self
    # sig intentionally omitted, because the wrapper will cause infinite recursion if certain methods are mocked
    #
    # source://mocktail//lib/mocktail/sorbet/mocktail/share/bind.rb#6
    def call(mock, method_name, *args, **kwargs, &blk); end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/cabinet.rb#8
class Mocktail::Cabinet
  # source://mocktail//lib/mocktail/sorbet/mocktail/value/cabinet.rb#24
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/cabinet.rb#15
  sig { returns(T::Array[::Mocktail::Call]) }
  def calls; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/cabinet.rb#85
  sig { params(double: ::Mocktail::Double).returns(T::Array[::Mocktail::Call]) }
  def calls_for_double(double); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/cabinet.rb#12
  sig { params(demonstration_in_progress: T::Boolean).void }
  def demonstration_in_progress=(demonstration_in_progress); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/cabinet.rb#65
  sig { returns(T::Boolean) }
  def demonstration_in_progress?; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/cabinet.rb#70
  sig { params(thing: T.anything).returns(T.nilable(::Mocktail::Double)) }
  def double_for_instance(thing); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/cabinet.rb#33
  sig { void }
  def reset!; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/cabinet.rb#50
  sig { params(call: ::Mocktail::Call).void }
  def store_call(call); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/cabinet.rb#45
  sig { params(double: ::Mocktail::Double).void }
  def store_double(double); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/cabinet.rb#55
  sig { params(stubbing: Mocktail::Stubbing[T.anything]).void }
  def store_stubbing(stubbing); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/cabinet.rb#60
  sig { params(unsatisfying_call: ::Mocktail::UnsatisfyingCall).void }
  def store_unsatisfying_call(unsatisfying_call); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/cabinet.rb#18
  sig { returns(T::Array[Mocktail::Stubbing[T.anything]]) }
  def stubbings; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/cabinet.rb#78
  sig { params(double: ::Mocktail::Double).returns(T::Array[Mocktail::Stubbing[T.anything]]) }
  def stubbings_for_double(double); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/cabinet.rb#21
  sig { returns(T::Array[::Mocktail::UnsatisfyingCall]) }
  def unsatisfying_calls; end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/call.rb#4
class Mocktail::Call < ::T::Struct
  const :singleton, T.nilable(T::Boolean)
  const :double, ::Object, default: T.unsafe(nil)
  const :original_type, T.nilable(T.any(::Module, T::Class[T.anything]))
  const :dry_type, T.nilable(T.any(::Module, T::Class[T.anything]))
  const :method, T.nilable(::Symbol)
  const :original_method, T.nilable(T.any(::Method, ::UnboundMethod))
  const :args, T::Array[T.untyped], default: T.unsafe(nil)
  const :kwargs, T::Hash[::Symbol, T.untyped], default: T.unsafe(nil)
  const :block, T.nilable(::Proc)

  # Because T::Struct compares with referential equality, we need
  # to redefine the equality methods to compare the values of the attributes.
  #
  # source://mocktail//lib/mocktail/sorbet/mocktail/value/call.rb#27
  # Because T::Struct compares with referential equality, we need
  sig { params(other: T.nilable(T.anything)).returns(T::Boolean) }
  def ==(other); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/call.rb#32
  sig { params(other: T.anything).returns(T::Boolean) }
  def eql?(other); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/call.rb#47
  sig { returns(::Integer) }
  def hash; end

  class << self
    # source://sorbet-runtime/0.5.10983/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/share/cleans_backtrace.rb#4
class Mocktail::CleansBacktrace
  # source://mocktail//lib/mocktail/sorbet/mocktail/share/cleans_backtrace.rb#12
  sig { type_parameters(:T).params(error: T.all(::StandardError, T.type_parameter(:T))).returns(T.type_parameter(:T)) }
  def clean(error); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/collects_calls.rb#4
class Mocktail::CollectsCalls
  # source://mocktail//lib/mocktail/sorbet/mocktail/collects_calls.rb#8
  sig { params(double: ::Object, method_name: T.nilable(::Symbol)).returns(T::Array[::Mocktail::Call]) }
  def collect(double, method_name); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/share/creates_identifier.rb#4
class Mocktail::CreatesIdentifier
  # source://mocktail//lib/mocktail/sorbet/mocktail/share/creates_identifier.rb#10
  sig { params(s: T.anything, default: ::String, max_length: ::Integer).returns(::String) }
  def create(s, default: T.unsafe(nil), max_length: T.unsafe(nil)); end

  private

  # source://mocktail//lib/mocktail/sorbet/mocktail/share/creates_identifier.rb#33
  sig { params(id: ::String, default: ::String).returns(::String) }
  def unreserved(id, default); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/share/creates_identifier.rb#7
Mocktail::CreatesIdentifier::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://mocktail//lib/mocktail/sorbet/mocktail/dsl.rb#4
module Mocktail::DSL
  # source://mocktail//lib/mocktail/sorbet/mocktail/dsl.rb#18
  sig do
    type_parameters(:T)
      .params(
        ignore_block: T::Boolean,
        ignore_extra_args: T::Boolean,
        ignore_arity: T::Boolean,
        times: T.nilable(::Integer),
        demo: T.proc.params(matchers: ::Mocktail::MatcherPresentation).returns(T.type_parameter(:T))
      ).returns(Mocktail::Stubbing[T.type_parameter(:T)])
  end
  def stubs(ignore_block: T.unsafe(nil), ignore_extra_args: T.unsafe(nil), ignore_arity: T.unsafe(nil), times: T.unsafe(nil), &demo); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/dsl.rb#37
  sig do
    params(
      ignore_block: T::Boolean,
      ignore_extra_args: T::Boolean,
      ignore_arity: T::Boolean,
      times: T.nilable(::Integer),
      demo: T.proc.params(matchers: ::Mocktail::MatcherPresentation).void
    ).void
  end
  def verify(ignore_block: T.unsafe(nil), ignore_extra_args: T.unsafe(nil), ignore_arity: T.unsafe(nil), times: T.unsafe(nil), &demo); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/debug.rb#4
module Mocktail::Debug
  class << self
    # It would be easy and bad for the mocktail lib to call something like
    #
    #   double == other_double
    #
    # But if it's a double, that means anyone who stubs that method could change
    # the internal behavior of the library in unexpected ways (as happened here:
    # https://github.com/testdouble/mocktail/issues/7 )
    #
    # For that reason when we run our tests, we also want to blow up if this
    # happens unintentionally. This works in conjunction with the test
    # MockingMethodfulClassesTest, because it mocks every defined method on the
    # mocked BasicObject
    #
    # source://mocktail//lib/mocktail/sorbet/mocktail/debug.rb#20
    # It would be easy and bad for the mocktail lib to call something like
    #   double == other_double
    # But if it's a double, that means anyone who stubs that method could change
    # the internal behavior of the library in unexpected ways (as happened here:
    # https://github.com/testdouble/mocktail/issues/7 )
    # For that reason when we run our tests, we also want to blow up if this
    # happens unintentionally. This works in conjunction with the test
    # MockingMethodfulClassesTest, because it mocks every defined method on the
    sig { void }
    def guard_against_mocktail_accidentally_calling_mocks_if_debugging!; end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/declares_dry_class.rb#6
class Mocktail::DeclaresDryClass
  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/declares_dry_class.rb#12
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/declares_dry_class.rb#23
  sig do
    type_parameters(:T)
      .params(
        type: T.all(T.type_parameter(:T), T::Class[::Object]),
        instance_methods: T::Array[::Symbol]
      ).returns(T.type_parameter(:T))
  end
  def declare(type, instance_methods); end

  private

  # These have special implementations, but if the user defines
  # any of them on the object itself, then they'll be replaced with normal
  # mocked methods. YMMV
  #
  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/declares_dry_class.rb#55
  # These have special implementations, but if the user defines
  # any of them on the object itself, then they'll be replaced with normal
  sig do
    params(
      dry_class: T::Class[::Object],
      type: T.any(::Module, T::Class[T.anything]),
      instance_methods: T::Array[::Symbol]
    ).void
  end
  def add_more_methods!(dry_class, type, instance_methods); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/declares_dry_class.rb#94
  sig do
    params(
      dry_class: T::Class[::Object],
      method_name: ::Symbol,
      type: T.any(::Module, T::Class[T.anything]),
      instance_methods: T::Array[::Symbol]
    ).void
  end
  def add_stringify_methods!(dry_class, method_name, type, instance_methods); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/declares_dry_class.rb#64
  sig do
    params(
      dry_class: T::Class[::Object],
      type: T.any(::Module, T::Class[T.anything]),
      instance_methods: T::Array[::Symbol]
    ).void
  end
  def define_double_methods!(dry_class, type, instance_methods); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/declares_dry_class.rb#115
  sig do
    params(
      dry_class: T::Class[::Object],
      type: T.any(::Module, T::Class[T.anything]),
      instance_methods: T::Array[::Symbol]
    ).void
  end
  def define_method_missing_errors!(dry_class, type, instance_methods); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/declares_dry_class.rb#9
Mocktail::DeclaresDryClass::DEFAULT_ANCESTORS = T.let(T.unsafe(nil), Array)

# source://mocktail//lib/mocktail/sorbet/mocktail/value/demo_config.rb#4
class Mocktail::DemoConfig < ::T::Struct
  const :ignore_block, T::Boolean, default: T.unsafe(nil)
  const :ignore_extra_args, T::Boolean, default: T.unsafe(nil)
  const :ignore_arity, T::Boolean, default: T.unsafe(nil)
  const :times, T.nilable(::Integer), default: T.unsafe(nil)

  class << self
    # source://sorbet-runtime/0.5.10983/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/fulfills_stubbing/describes_unsatisfied_stubbing.rb#7
class Mocktail::DescribesUnsatisfiedStubbing
  # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/fulfills_stubbing/describes_unsatisfied_stubbing.rb#11
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/fulfills_stubbing/describes_unsatisfied_stubbing.rb#16
  sig { params(dry_call: ::Mocktail::Call).returns(::Mocktail::UnsatisfyingCall) }
  def describe(dry_call); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/share/determines_matching_calls.rb#6
class Mocktail::DeterminesMatchingCalls
  # source://mocktail//lib/mocktail/sorbet/mocktail/share/determines_matching_calls.rb#10
  sig do
    params(
      real_call: ::Mocktail::Call,
      demo_call: ::Mocktail::Call,
      demo_config: ::Mocktail::DemoConfig
    ).returns(T::Boolean)
  end
  def determine(real_call, demo_call, demo_config); end

  private

  # source://mocktail//lib/mocktail/sorbet/mocktail/share/determines_matching_calls.rb#23
  sig do
    params(
      real_args: T::Array[T.untyped],
      demo_args: T::Array[T.untyped],
      ignore_extra_args: T::Boolean
    ).returns(T::Boolean)
  end
  def args_match?(real_args, demo_args, ignore_extra_args); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/share/determines_matching_calls.rb#50
  sig do
    params(
      real_block: T.nilable(::Proc),
      demo_block: T.nilable(::Proc),
      ignore_block: T::Boolean
    ).returns(T::Boolean)
  end
  def blocks_match?(real_block, demo_block, ignore_block); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/share/determines_matching_calls.rb#37
  sig do
    params(
      real_kwargs: T::Hash[::Symbol, T.untyped],
      demo_kwargs: T::Hash[::Symbol, T.untyped],
      ignore_extra_args: T::Boolean
    ).returns(T::Boolean)
  end
  def kwargs_match?(real_kwargs, demo_kwargs, ignore_extra_args); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/share/determines_matching_calls.rb#63
  sig { params(real_arg: T.untyped, demo_arg: T.untyped).returns(T::Boolean) }
  def match?(real_arg, demo_arg); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/double.rb#4
class Mocktail::Double < ::T::Struct
  const :original_type, T.any(::Module, T::Class[T.anything])
  const :dry_type, T::Class[T.anything]
  const :dry_instance, ::Object
  const :dry_methods, T::Array[::Symbol]

  class << self
    # source://sorbet-runtime/0.5.10983/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/double_data.rb#7
class Mocktail::DoubleData < ::T::Struct
  include ::Mocktail::ExplanationData

  const :type, T.any(::Module, T::Class[T.anything])
  const :double, ::Object
  const :calls, T::Array[::Mocktail::Call]
  const :stubbings, T::Array[Mocktail::Stubbing[T.anything]]

  class << self
    # source://sorbet-runtime/0.5.10983/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#36
class Mocktail::DoubleExplanation < ::Mocktail::Explanation
  # source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#41
  sig { params(reference: ::Mocktail::DoubleData, message: ::String).void }
  def initialize(reference, message); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#38
  sig { override.returns(::Mocktail::DoubleData) }
  def reference; end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/ensures_imitation_support.rb#4
class Mocktail::EnsuresImitationSupport
  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/ensures_imitation_support.rb#8
  sig { params(type: T.any(::Module, T::Class[T.anything])).void }
  def ensure(type); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/errors.rb#4
class Mocktail::Error < ::StandardError; end

# source://mocktail//lib/mocktail/sorbet/mocktail/explains_nils.rb#7
class Mocktail::ExplainsNils
  # source://mocktail//lib/mocktail/sorbet/mocktail/explains_nils.rb#11
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/explains_nils.rb#17
  sig { returns(T::Array[::Mocktail::UnsatisfyingCallExplanation]) }
  def explain; end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/explains_thing.rb#7
class Mocktail::ExplainsThing
  # source://mocktail//lib/mocktail/sorbet/mocktail/explains_thing.rb#11
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/explains_thing.rb#17
  sig { params(thing: ::Object).returns(::Mocktail::Explanation) }
  def explain(thing); end

  private

  # source://mocktail//lib/mocktail/sorbet/mocktail/explains_thing.rb#54
  sig { params(double: ::Mocktail::Double).returns(::Mocktail::DoubleData) }
  def data_for_double(double); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/explains_thing.rb#78
  sig { params(type_replacement: ::Mocktail::TypeReplacement).returns(::Mocktail::TypeReplacementData) }
  def data_for_type_replacement(type_replacement); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/explains_thing.rb#106
  sig do
    params(
      double_data: T.any(::Mocktail::DoubleData, ::Mocktail::TypeReplacementData),
      method: ::Symbol
    ).returns(::String)
  end
  def describe_dry_method(double_data, method); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/explains_thing.rb#64
  sig { params(double: ::Mocktail::Double).returns(::Mocktail::DoubleExplanation) }
  def double_explanation(double); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/explains_thing.rb#33
  sig { params(thing: ::Object).returns(T.nilable(::Mocktail::FakeMethodExplanation)) }
  def fake_method_explanation_for(thing); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/explains_thing.rb#132
  sig { params(thing: ::Object).returns(::Mocktail::NoExplanation) }
  def no_explanation(thing); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/explains_thing.rb#92
  sig { params(type_replacement: ::Mocktail::TypeReplacement).returns(::Mocktail::ReplacedTypeExplanation) }
  def replaced_type_explanation(type_replacement); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#4
class Mocktail::Explanation
  # source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#14
  sig { params(reference: ::Mocktail::ExplanationData, message: ::String).void }
  def initialize(reference, message); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#11
  sig { returns(::String) }
  def message; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#8
  sig { returns(::Mocktail::ExplanationData) }
  def reference; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#20
  sig { returns(T.class_of(Mocktail::Explanation)) }
  def type; end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation_data.rb#4
module Mocktail::ExplanationData
  include ::Kernel

  interface!

  # @abstract
  #
  # source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation_data.rb#12
  sig { abstract.returns(T::Array[::Mocktail::Call]) }
  def calls; end

  # @abstract
  #
  # source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation_data.rb#16
  sig { abstract.returns(T::Array[Mocktail::Stubbing[T.anything]]) }
  def stubbings; end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/fake_method_data.rb#4
class Mocktail::FakeMethodData < ::T::Struct
  include ::Mocktail::ExplanationData

  const :receiver, T.anything
  const :calls, T::Array[::Mocktail::Call]
  const :stubbings, T::Array[Mocktail::Stubbing[T.anything]]

  class << self
    # source://sorbet-runtime/0.5.10983/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#58
class Mocktail::FakeMethodExplanation < ::Mocktail::Explanation
  # source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#63
  sig { params(reference: ::Mocktail::FakeMethodData, message: ::String).void }
  def initialize(reference, message); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#60
  sig { override.returns(::Mocktail::FakeMethodData) }
  def reference; end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/fulfills_stubbing/finds_satisfaction.rb#6
class Mocktail::FindsSatisfaction
  # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/fulfills_stubbing/finds_satisfaction.rb#10
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/fulfills_stubbing/finds_satisfaction.rb#15
  sig { params(dry_call: ::Mocktail::Call).returns(T.nilable(Mocktail::Stubbing[T.anything])) }
  def find(dry_call); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/verifies_call/finds_verifiable_calls.rb#6
class Mocktail::FindsVerifiableCalls
  # source://mocktail//lib/mocktail/sorbet/mocktail/verifies_call/finds_verifiable_calls.rb#10
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/verifies_call/finds_verifiable_calls.rb#15
  sig { params(recording: ::Mocktail::Call, demo_config: ::Mocktail::DemoConfig).returns(T::Array[::Mocktail::Call]) }
  def find(recording, demo_config); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/fulfills_stubbing.rb#7
class Mocktail::FulfillsStubbing
  # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/fulfills_stubbing.rb#11
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/fulfills_stubbing.rb#17
  sig { params(dry_call: ::Mocktail::Call).returns(T.anything) }
  def fulfill(dry_call); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/fulfills_stubbing.rb#28
  sig { params(dry_call: ::Mocktail::Call).returns(T.nilable(Mocktail::Stubbing[T.anything])) }
  def satisfaction(dry_call); end

  private

  # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/fulfills_stubbing.rb#37
  sig { params(dry_call: ::Mocktail::Call).void }
  def store_unsatisfying_call!(dry_call); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/verifies_call/raises_verification_error/gathers_calls_of_method.rb#4
class Mocktail::GathersCallsOfMethod
  # source://mocktail//lib/mocktail/sorbet/mocktail/verifies_call/raises_verification_error/gathers_calls_of_method.rb#8
  sig { params(dry_call: ::Mocktail::Call).returns(T::Array[::Mocktail::Call]) }
  def gather(dry_call); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/gathers_fakeable_instance_methods.rb#4
class Mocktail::GathersFakeableInstanceMethods
  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/gathers_fakeable_instance_methods.rb#8
  sig { params(type: T.any(::Module, T::Class[T.anything])).returns(T::Array[::Symbol]) }
  def gather(type); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/gathers_fakeable_instance_methods.rb#19
  sig { params(type: T.any(::Module, T::Class[T.anything]), method_name: ::Symbol).returns(T::Boolean) }
  def ignore?(type, method_name); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/gathers_fakeable_instance_methods.rb#24
  sig { returns(T::Array[::Module]) }
  def ignored_ancestors; end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/grabs_original_method_parameters.rb#4
class Mocktail::GrabsOriginalMethodParameters
  # Sorbet wraps the original method in a sig wrapper, so we need to unwrap it.
  # The value returned from `owner.instance_method(method_name)` does not have
  # the real parameters values available, as they'll have been erased
  #
  # If the method isn't wrapped by Sorbet, this will return the #instance_method,
  # per usual
  #
  # source://mocktail//lib/mocktail/sorbet/mocktail/grabs_original_method_parameters.rb#14
  # Sorbet wraps the original method in a sig wrapper, so we need to unwrap it.
  # The value returned from `owner.instance_method(method_name)` does not have
  # the real parameters values available, as they'll have been erased
  # If the method isn't wrapped by Sorbet, this will return the #instance_method,
  sig { params(method: T.nilable(T.any(::Method, ::UnboundMethod))).returns(T::Array[T::Array[::Symbol]]) }
  def grab(method); end

  private

  # source://mocktail//lib/mocktail/sorbet/mocktail/grabs_original_method_parameters.rb#27
  sig { params(method: T.any(::Method, ::UnboundMethod)).returns(T.nilable(::T::Private::Methods::Signature)) }
  def sorbet_wrapped_method(method); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call.rb#8
class Mocktail::HandlesDryCall
  # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call.rb#12
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call.rb#19
  sig { params(dry_call: ::Mocktail::Call).returns(T.anything) }
  def handle(dry_call); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_new_call.rb#4
class Mocktail::HandlesDryNewCall
  # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_new_call.rb#8
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_new_call.rb#16
  sig do
    params(
      type: T::Class[T.all(::Object, ::T)],
      args: T::Array[T.anything],
      kwargs: T::Hash[::Symbol, T.anything],
      block: T.nilable(::Proc)
    ).returns(T.anything)
  end
  def handle(type, args, kwargs, block); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type.rb#7
class Mocktail::ImitatesType
  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type.rb#12
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type.rb#22
  sig do
    type_parameters(:T)
      .params(
        type: T::Class[T.all(::Object, T.type_parameter(:T))]
      ).returns(T.all(::Object, T.type_parameter(:T)))
  end
  def imitate(type); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/initializes_mocktail.rb#4
class Mocktail::InitializesMocktail
  # source://mocktail//lib/mocktail/sorbet/mocktail/initializes_mocktail.rb#8
  sig { void }
  def init; end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/errors.rb#14
class Mocktail::InvalidMatcherError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/logs_call.rb#4
class Mocktail::LogsCall
  # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/logs_call.rb#8
  sig { params(dry_call: ::Mocktail::Call).void }
  def log(dry_call); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double.rb#7
class Mocktail::MakesDouble
  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double.rb#11
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double.rb#17
  sig { params(type: T::Class[::Object]).returns(::Mocktail::Double) }
  def make(type); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/matcher_presentation.rb#4
class Mocktail::MatcherPresentation
  sig { returns(T.untyped) }
  def any; end

  sig { type_parameters(:T).params(expecteds: T.type_parameter(:T)).returns(T::Array[T.type_parameter(:T)]) }
  def includes(*expecteds); end

  sig do
    type_parameters(:K, :V)
      .params(
        expecteds: T::Hash[T.type_parameter(:K), T.type_parameter(:V)]
      ).returns(T::Hash[T.type_parameter(:K), T.type_parameter(:V)])
  end
  def includes_hash(*expecteds); end

  sig do
    type_parameters(:K, :V)
      .params(
        expecteds: T.type_parameter(:K)
      ).returns(T::Hash[T.type_parameter(:K), T.type_parameter(:V)])
  end
  def includes_key(*expecteds); end

  sig { type_parameters(:T).params(expecteds: T.type_parameter(:T)).returns(T.type_parameter(:T)) }
  def includes_string(*expecteds); end

  sig { type_parameters(:T).params(expected: T::Class[T.type_parameter(:T)]).returns(T.type_parameter(:T)) }
  def is_a(expected); end

  sig { params(pattern: T.any(String, Regexp)).returns(String) }
  def matches(pattern); end

  # standard:disable Style/ArgumentsForwarding
  #
  # source://mocktail//lib/mocktail/sorbet/mocktail/matcher_presentation.rb#13
  sig { params(name: ::Symbol, args: T.anything, kwargs: T.anything, blk: T.nilable(::Proc)).returns(T.anything) }
  def method_missing(name, *args, **kwargs, &blk); end

  sig { type_parameters(:T).params(unexpected: T.type_parameter(:T)).returns(T.type_parameter(:T)) }
  def not(unexpected); end

  sig { returns(T.untyped) }
  def numeric; end

  sig { params(blk: T.proc.params(arg: T.untyped).returns(T::Boolean)).returns(T.untyped) }
  def that(&blk); end

  private

  # source://mocktail//lib/mocktail/sorbet/mocktail/matcher_presentation.rb#8
  sig { params(name: ::Symbol, include_private: T::Boolean).returns(T::Boolean) }
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/matcher_registry.rb#4
class Mocktail::MatcherRegistry
  # source://mocktail//lib/mocktail/sorbet/mocktail/value/matcher_registry.rb#13
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/matcher_registry.rb#18
  sig { params(matcher_type: T.class_of(Mocktail::Matchers::Base)).void }
  def add(matcher_type); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/matcher_registry.rb#23
  sig { params(name: ::Symbol).returns(T.nilable(T.class_of(Mocktail::Matchers::Base))) }
  def get(name); end

  class << self
    # source://mocktail//lib/mocktail/sorbet/mocktail/value/matcher_registry.rb#8
    sig { returns(::Mocktail::MatcherRegistry) }
    def instance; end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/matchers.rb#4
module Mocktail::Matchers; end

# source://mocktail//lib/mocktail/sorbet/mocktail/matchers/any.rb#4
class Mocktail::Matchers::Any < ::Mocktail::Matchers::Base
  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/any.rb#13
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/any.rb#23
  sig { returns(::String) }
  def inspect; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/any.rb#18
  sig { params(actual: T.anything).returns(T::Boolean) }
  def match?(actual); end

  class << self
    # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/any.rb#8
    sig { returns(::Symbol) }
    def matcher_name; end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://mocktail//lib/mocktail/sorbet/mocktail/matchers/base.rb#4
class Mocktail::Matchers::Base
  # Custom matchers can receive any args, kwargs, or block they want. Usually
  # single-argument, though, so that's defaulted here and in #insepct
  #
  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/base.rb#15
  # Custom matchers can receive any args, kwargs, or block they want. Usually
  sig { params(expected: ::BasicObject).void }
  def initialize(expected); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/base.rb#30
  sig { returns(::String) }
  def inspect; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/base.rb#35
  sig { returns(::TrueClass) }
  def is_mocktail_matcher?; end

  # @raise [Mocktail::InvalidMatcherError]
  #
  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/base.rb#25
  sig { params(actual: T.untyped).returns(T::Boolean) }
  def match?(actual); end

  class << self
    # @raise [Mocktail::InvalidMatcherError]
    #
    # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/base.rb#20
    sig { returns(::Symbol) }
    def matcher_name; end
  end
end

# Captors are conceptually complex implementations, but with a simple usage/purpose:
# They are values the user can create and hold onto that will return a matcher
# and then "capture" the value made by the real call, for later analysis & assertion.
#
# Unlike other matchers, these don't make any useful sense for stubbing, but are
# very useful when asserting complication call verifications
#
# The fact the user will need the reference outside the verification call is
# why this is a top-level method on Mocktail, and not included in the |m| block
# arg to stubs/verify
#
# See Mockito, which is the earliest implementation I know of:
# https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Captor.html
#
# source://mocktail//lib/mocktail/sorbet/mocktail/matchers/captor.rb#17
# Captors are conceptually complex implementations, but with a simple usage/purpose:
# They are values the user can create and hold onto that will return a matcher
# and then "capture" the value made by the real call, for later analysis & assertion.
# Unlike other matchers, these don't make any useful sense for stubbing, but are
# very useful when asserting complication call verifications
# The fact the user will need the reference outside the verification call is
# why this is a top-level method on Mocktail, and not included in the |m| block
# arg to stubs/verify
# See Mockito, which is the earliest implementation I know of:
class Mocktail::Matchers::Captor
  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/captor.rb#62
  sig { void }
  def initialize; end

  # This T.untyped is intentional. Even though a Capture is surely returned,
  # in order for a verification demonstration to pass its own type check,
  # it needs to think it's being returned whatever parameter is expected
  #
  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/captor.rb#59
  # This T.untyped is intentional. Even though a Capture is surely returned,
  # in order for a verification demonstration to pass its own type check,
  sig { returns(T.untyped) }
  def capture; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/captor.rb#67
  sig { returns(T::Boolean) }
  def captured?; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/captor.rb#72
  sig { returns(T.untyped) }
  def value; end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/matchers/captor.rb#20
class Mocktail::Matchers::Captor::Capture < ::Mocktail::Matchers::Base
  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/captor.rb#32
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/captor.rb#45
  sig { returns(T::Boolean) }
  def captured?; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/captor.rb#50
  sig { returns(::String) }
  def inspect; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/captor.rb#38
  sig { params(actual: T.untyped).returns(::TrueClass) }
  def match?(actual); end

  # Returns the value of attribute value.
  #
  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/captor.rb#29
  sig { returns(T.untyped) }
  def value; end

  class << self
    # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/captor.rb#24
    sig { returns(::Symbol) }
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/matchers/includes.rb#4
class Mocktail::Matchers::Includes < ::Mocktail::Matchers::Base
  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/includes.rb#13
  sig { params(expecteds: T.untyped).void }
  def initialize(*expecteds); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/includes.rb#28
  sig { returns(::String) }
  def inspect; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/includes.rb#18
  sig { params(actual: T.untyped).returns(T::Boolean) }
  def match?(actual); end

  class << self
    # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/includes.rb#8
    sig { returns(::Symbol) }
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/matchers/includes_hash.rb#4
class Mocktail::Matchers::IncludesHash < ::Mocktail::Matchers::Includes
  class << self
    # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/includes_hash.rb#8
    sig { returns(::Symbol) }
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/matchers/includes_key.rb#4
class Mocktail::Matchers::IncludesKey < ::Mocktail::Matchers::Includes
  class << self
    # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/includes_key.rb#8
    sig { returns(::Symbol) }
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/matchers/includes_string.rb#4
class Mocktail::Matchers::IncludesString < ::Mocktail::Matchers::Includes
  class << self
    # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/includes_string.rb#8
    sig { returns(::Symbol) }
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/matchers/is_a.rb#4
class Mocktail::Matchers::IsA < ::Mocktail::Matchers::Base
  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/is_a.rb#13
  sig { params(actual: T.untyped).returns(T::Boolean) }
  def match?(actual); end

  class << self
    # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/is_a.rb#8
    sig { returns(::Symbol) }
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/matchers/matches.rb#4
class Mocktail::Matchers::Matches < ::Mocktail::Matchers::Base
  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/matches.rb#13
  sig { params(actual: T.untyped).returns(T::Boolean) }
  def match?(actual); end

  class << self
    # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/matches.rb#8
    sig { returns(::Symbol) }
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/matchers/not.rb#4
class Mocktail::Matchers::Not < ::Mocktail::Matchers::Base
  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/not.rb#13
  sig { params(actual: T.untyped).returns(T::Boolean) }
  def match?(actual); end

  class << self
    # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/not.rb#8
    sig { returns(::Symbol) }
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/matchers/numeric.rb#4
class Mocktail::Matchers::Numeric < ::Mocktail::Matchers::Base
  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/numeric.rb#13
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/numeric.rb#23
  sig { returns(::String) }
  def inspect; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/numeric.rb#18
  sig { params(actual: T.untyped).returns(T::Boolean) }
  def match?(actual); end

  class << self
    # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/numeric.rb#8
    sig { returns(::Symbol) }
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/matchers/that.rb#4
class Mocktail::Matchers::That < ::Mocktail::Matchers::Base
  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/that.rb#13
  sig { params(blk: T.nilable(T.proc.params(actual: T.untyped).returns(T.untyped))).void }
  def initialize(&blk); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/that.rb#28
  sig { returns(::String) }
  def inspect; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/that.rb#21
  sig { params(actual: T.untyped).returns(T::Boolean) }
  def match?(actual); end

  class << self
    # source://mocktail//lib/mocktail/sorbet/mocktail/matchers/that.rb#8
    sig { returns(::Symbol) }
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/errors.rb#10
class Mocktail::MissingDemonstrationError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#25
class Mocktail::NoExplanation < ::Mocktail::Explanation
  # source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#30
  sig { params(reference: ::Mocktail::NoExplanationData, message: ::String).void }
  def initialize(reference, message); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#27
  sig { override.returns(::Mocktail::NoExplanationData) }
  def reference; end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/no_explanation_data.rb#4
class Mocktail::NoExplanationData < ::T::Struct
  include ::Mocktail::ExplanationData

  const :thing, ::Object

  # @raise [Error]
  #
  # source://mocktail//lib/mocktail/sorbet/mocktail/value/no_explanation_data.rb#11
  sig { override.returns(T::Array[::Mocktail::Call]) }
  def calls; end

  # @raise [Error]
  #
  # source://mocktail//lib/mocktail/sorbet/mocktail/value/no_explanation_data.rb#16
  sig { override.returns(T::Array[Mocktail::Stubbing[T.anything]]) }
  def stubbings; end

  class << self
    # source://sorbet-runtime/0.5.10983/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/signature.rb#4
class Mocktail::Params < ::T::Struct
  prop :all, T::Array[::Symbol], default: T.unsafe(nil)
  prop :required, T::Array[::Symbol], default: T.unsafe(nil)
  prop :optional, T::Array[::Symbol], default: T.unsafe(nil)
  prop :rest, T.nilable(::Symbol)

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/signature.rb#13
  sig { returns(T::Array[::Symbol]) }
  def allowed; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/signature.rb#18
  sig { returns(T::Boolean) }
  def rest?; end

  class << self
    # source://sorbet-runtime/0.5.10983/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/raises_neato_no_method_error.rb#8
class Mocktail::RaisesNeatoNoMethodError
  # source://mocktail//lib/mocktail/sorbet/mocktail/raises_neato_no_method_error.rb#12
  sig { void }
  def initialize; end

  # @raise [NoMethodError]
  #
  # source://mocktail//lib/mocktail/sorbet/mocktail/raises_neato_no_method_error.rb#19
  sig { params(call: ::Mocktail::Call).void }
  def call(call); end

  private

  # source://mocktail//lib/mocktail/sorbet/mocktail/raises_neato_no_method_error.rb#63
  sig { params(block: T.nilable(::Proc)).returns(T.nilable(::String)) }
  def block_param(block); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/raises_neato_no_method_error.rb#81
  sig { params(call: ::Mocktail::Call).returns(T.nilable(::String)) }
  def corrections(call); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/raises_neato_no_method_error.rb#70
  sig { params(identifiers: T::Array[::String]).returns(T::Array[::String]) }
  def count_repeats(identifiers); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/raises_neato_no_method_error.rb#56
  sig { params(kwargs: T::Hash[::Symbol, T.anything]).returns(T.nilable(::String)) }
  def kwparams_list(kwargs); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/raises_neato_no_method_error.rb#36
  sig { params(call: ::Mocktail::Call).returns(T.nilable(::String)) }
  def params(call); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/raises_neato_no_method_error.rb#47
  sig { params(args: T::Array[T.anything]).returns(T.nilable(::String)) }
  def params_list(args); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/verifies_call/raises_verification_error.rb#8
class Mocktail::RaisesVerificationError
  # source://mocktail//lib/mocktail/sorbet/mocktail/verifies_call/raises_verification_error.rb#12
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/verifies_call/raises_verification_error.rb#19
  sig do
    params(
      recording: ::Mocktail::Call,
      verifiable_calls: T::Array[::Mocktail::Call],
      demo_config: ::Mocktail::DemoConfig
    ).void
  end
  def raise(recording, verifiable_calls, demo_config); end

  private

  # source://mocktail//lib/mocktail/sorbet/mocktail/verifies_call/raises_verification_error.rb#50
  sig do
    params(
      recording: ::Mocktail::Call,
      verifiable_calls: T::Array[::Mocktail::Call],
      demo_config: ::Mocktail::DemoConfig
    ).returns(T.nilable(::String))
  end
  def describe_other_calls(recording, verifiable_calls, demo_config); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/verifies_call/raises_verification_error.rb#39
  sig { params(demo_config: ::Mocktail::DemoConfig, count: ::Integer).returns(T.nilable(::String)) }
  def describe_verifiable_times_called(demo_config, count); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/verifies_call/raises_verification_error.rb#66
  sig { params(s: ::String, count: T.nilable(::Integer)).returns(::String) }
  def pl(s, count); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/simulates_argument_error/reconciles_args_with_params.rb#4
class Mocktail::ReconcilesArgsWithParams
  # source://mocktail//lib/mocktail/sorbet/mocktail/simulates_argument_error/reconciles_args_with_params.rb#8
  sig { params(signature: ::Mocktail::Signature).returns(T::Boolean) }
  def reconcile(signature); end

  private

  # source://mocktail//lib/mocktail/sorbet/mocktail/simulates_argument_error/reconciles_args_with_params.rb#16
  sig { params(arg_params: ::Mocktail::Params, args: T::Array[T.untyped]).returns(T::Boolean) }
  def args_match?(arg_params, args); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/simulates_argument_error/reconciles_args_with_params.rb#22
  sig { params(kwarg_params: ::Mocktail::Params, kwargs: T::Hash[::Symbol, T.untyped]).returns(T::Boolean) }
  def kwargs_match?(kwarg_params, kwargs); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/declares_dry_class/reconstructs_call.rb#4
class Mocktail::ReconstructsCall
  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/declares_dry_class/reconstructs_call.rb#19
  sig do
    params(
      double: ::Object,
      call_binding: ::Binding,
      default_args: T.nilable(T::Hash[::Symbol, T.anything]),
      dry_class: T::Class[::Object],
      type: T.any(::Module, T::Class[T.anything]),
      method: ::Symbol,
      original_method: T.any(::Method, ::UnboundMethod),
      signature: ::Mocktail::Signature
    ).returns(::Mocktail::Call)
  end
  def reconstruct(double:, call_binding:, default_args:, dry_class:, type:, method:, original_method:, signature:); end

  private

  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/declares_dry_class/reconstructs_call.rb#39
  sig do
    params(
      signature: ::Mocktail::Signature,
      call_binding: ::Binding,
      default_args: T.nilable(T::Hash[::Symbol, T.anything])
    ).returns(T::Array[T.anything])
  end
  def args_for(signature, call_binding, default_args); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/declares_dry_class/reconstructs_call.rb#52
  sig do
    params(
      signature: ::Mocktail::Signature,
      call_binding: ::Binding,
      default_args: T.nilable(T::Hash[::Symbol, T.anything])
    ).returns(T::Hash[::Symbol, T.anything])
  end
  def kwargs_for(signature, call_binding, default_args); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/imitates_type/makes_double/declares_dry_class/reconstructs_call.rb#62
  sig do
    params(
      params: ::Mocktail::Params,
      default_args: T.nilable(T::Hash[::Symbol, T.anything])
    ).returns([T::Array[::Symbol], T.nilable(::Symbol)])
  end
  def non_default_args(params, default_args); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/records_demonstration.rb#4
class Mocktail::RecordsDemonstration
  # source://mocktail//lib/mocktail/sorbet/mocktail/records_demonstration.rb#14
  sig do
    type_parameters(:T)
      .params(
        demonstration: T.proc.params(matchers: ::Mocktail::MatcherPresentation).returns(T.type_parameter(:T)),
        demo_config: ::Mocktail::DemoConfig
      ).returns(::Mocktail::Call)
  end
  def record(demonstration, demo_config); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/simulates_argument_error/recreates_message.rb#4
class Mocktail::RecreatesMessage
  # source://mocktail//lib/mocktail/sorbet/mocktail/simulates_argument_error/recreates_message.rb#8
  sig { params(signature: ::Mocktail::Signature).returns(::String) }
  def recreate(signature); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/replaces_type/redefines_new.rb#4
class Mocktail::RedefinesNew
  # source://mocktail//lib/mocktail/sorbet/mocktail/replaces_type/redefines_new.rb#8
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/replaces_type/redefines_new.rb#13
  sig { params(type: T.any(::Module, T::Class[T.anything])).void }
  def redefine(type); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/replaces_type/redefines_singleton_methods.rb#4
class Mocktail::RedefinesSingletonMethods
  # source://mocktail//lib/mocktail/sorbet/mocktail/replaces_type/redefines_singleton_methods.rb#8
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/replaces_type/redefines_singleton_methods.rb#47
  sig { params(type: T.any(::Module, T::Class[T.anything])).void }
  def declare_singleton_method_missing_errors!(type); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/replaces_type/redefines_singleton_methods.rb#13
  sig { params(type: T.any(::Module, T::Class[T.anything])).void }
  def redefine(type); end

  private

  # source://mocktail//lib/mocktail/sorbet/mocktail/replaces_type/redefines_singleton_methods.rb#72
  sig { params(method: ::Method).returns(T::Boolean) }
  def sorbet_method_hook?(method); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/registers_matcher.rb#4
class Mocktail::RegistersMatcher
  # source://mocktail//lib/mocktail/sorbet/mocktail/registers_matcher.rb#8
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/registers_matcher.rb#13
  sig { params(matcher_type: T.class_of(Mocktail::Matchers::Base)).void }
  def register(matcher_type); end

  private

  # source://mocktail//lib/mocktail/sorbet/mocktail/registers_matcher.rb#59
  sig { params(matcher_type: T.class_of(Mocktail::Matchers::Base)).returns(T::Boolean) }
  def invalid_flag?(matcher_type); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/registers_matcher.rb#51
  sig { params(matcher_type: T.class_of(Mocktail::Matchers::Base)).returns(T::Boolean) }
  def invalid_match?(matcher_type); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/registers_matcher.rb#43
  sig { params(matcher_type: T.class_of(Mocktail::Matchers::Base)).returns(T::Boolean) }
  def invalid_name?(matcher_type); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/registers_matcher.rb#38
  sig { params(matcher_type: T.class_of(Mocktail::Matchers::Base)).returns(T::Boolean) }
  def invalid_type?(matcher_type); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/registers_stubbing.rb#6
class Mocktail::RegistersStubbing
  # source://mocktail//lib/mocktail/sorbet/mocktail/registers_stubbing.rb#10
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/registers_stubbing.rb#21
  sig do
    type_parameters(:T)
      .params(
        demonstration: T.proc.params(matchers: ::Mocktail::MatcherPresentation).returns(T.type_parameter(:T)),
        demo_config: ::Mocktail::DemoConfig
      ).returns(Mocktail::Stubbing[T.type_parameter(:T)])
  end
  def register(demonstration, demo_config); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#47
class Mocktail::ReplacedTypeExplanation < ::Mocktail::Explanation
  # source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#52
  sig { params(reference: ::Mocktail::TypeReplacementData, message: ::String).void }
  def initialize(reference, message); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/explanation.rb#49
  sig { override.returns(::Mocktail::TypeReplacementData) }
  def reference; end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/replaces_next.rb#4
class Mocktail::ReplacesNext
  # source://mocktail//lib/mocktail/sorbet/mocktail/replaces_next.rb#8
  sig { void }
  def initialize; end

  # @raise [UnsupportedMocktail]
  #
  # source://mocktail//lib/mocktail/sorbet/mocktail/replaces_next.rb#28
  sig do
    type_parameters(:T)
      .params(
        type: T::Class[T.all(::Object, T.type_parameter(:T))],
        count: ::Integer
      ).returns(T::Array[T.type_parameter(:T)])
  end
  def replace(type, count); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/replaces_next.rb#19
  sig do
    type_parameters(:T)
      .params(
        type: T::Class[T.all(::Object, T.type_parameter(:T))]
      ).returns(T.type_parameter(:T))
  end
  def replace_once(type); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/replaces_type.rb#8
class Mocktail::ReplacesType
  # source://mocktail//lib/mocktail/sorbet/mocktail/replaces_type.rb#12
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/replaces_type.rb#20
  sig { params(type: T.any(::Module, T::Class[T.anything])).void }
  def replace(type); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/resets_state.rb#4
class Mocktail::ResetsState
  # source://mocktail//lib/mocktail/sorbet/mocktail/resets_state.rb#8
  sig { void }
  def reset; end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/replaces_type/runs_sorbet_sig_blocks_before_replacement.rb#4
class Mocktail::RunsSorbetSigBlocksBeforeReplacement
  # This is necessary because when Sorbet runs a sig block of a singleton
  # method, it has the net effect of unwrapping/redefining the method. If
  # we try to use Mocktail.replace(Foo) and Foo.bar has a Sorbet sig block,
  # then we'll end up with three "versions" of the same method and no way
  # to keep straight which one == which:
  #
  #  A - Foo.bar, as defined in the original class
  #  B - Foo.bar, as redefined by RedefinesSingletonMethods
  #  C - Foo.bar, as wrapped by sorbet-runtime
  #
  # Initially, Foo.method(:bar) would == C, but after the type
  # replacement, it would == B (with a reference back to C as the original),
  # but after handling a single dry call, our invocation of
  # GrabsOriginalMethodParameters.grab(Foo.method(:bar)) would invoke the
  # Sorbet `sig` block, which has the net effect of redefining the method back
  # to A.
  #
  # It's very fun and confusing and a great time.
  #
  # source://mocktail//lib/mocktail/sorbet/mocktail/replaces_type/runs_sorbet_sig_blocks_before_replacement.rb#26
  # This is necessary because when Sorbet runs a sig block of a singleton
  # method, it has the net effect of unwrapping/redefining the method. If
  # we try to use Mocktail.replace(Foo) and Foo.bar has a Sorbet sig block,
  # then we'll end up with three "versions" of the same method and no way
  # to keep straight which one == which:
  #  A - Foo.bar, as defined in the original class
  #  B - Foo.bar, as redefined by RedefinesSingletonMethods
  #  C - Foo.bar, as wrapped by sorbet-runtime
  # Initially, Foo.method(:bar) would == C, but after the type
  # replacement, it would == B (with a reference back to C as the original),
  # but after handling a single dry call, our invocation of
  # GrabsOriginalMethodParameters.grab(Foo.method(:bar)) would invoke the
  # Sorbet `sig` block, which has the net effect of redefining the method back
  # to A.
  sig { params(type: T.any(::Module, T::Class[T.anything])).void }
  def run(type); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/signature.rb#23
class Mocktail::Signature < ::T::Struct
  const :positional_params, ::Mocktail::Params
  const :positional_args, T::Array[T.anything]
  const :keyword_params, ::Mocktail::Params
  const :keyword_args, T::Hash[::Symbol, T.anything]
  const :block_param, T.nilable(::Symbol)
  const :block_arg, T.nilable(::Proc), default: T.unsafe(nil)

  class << self
    # source://sorbet-runtime/0.5.10983/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/signature.rb#33
Mocktail::Signature::DEFAULT_BLOCK_PARAM = T.let(T.unsafe(nil), String)

# source://mocktail//lib/mocktail/sorbet/mocktail/value/signature.rb#31
Mocktail::Signature::DEFAULT_REST_ARGS = T.let(T.unsafe(nil), String)

# source://mocktail//lib/mocktail/sorbet/mocktail/value/signature.rb#32
Mocktail::Signature::DEFAULT_REST_KWARGS = T.let(T.unsafe(nil), String)

# source://mocktail//lib/mocktail/sorbet/mocktail/simulates_argument_error.rb#10
class Mocktail::SimulatesArgumentError
  # source://mocktail//lib/mocktail/sorbet/mocktail/simulates_argument_error.rb#14
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/simulates_argument_error.rb#23
  sig { params(dry_call: ::Mocktail::Call).returns(T.nilable(::ArgumentError)) }
  def simulate(dry_call); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/share/stringifies_call.rb#4
class Mocktail::StringifiesCall
  # source://mocktail//lib/mocktail/sorbet/mocktail/share/stringifies_call.rb#8
  sig { params(call: ::Mocktail::Call, anonymous_blocks: T::Boolean, always_parens: T::Boolean).returns(::String) }
  def stringify(call, anonymous_blocks: T.unsafe(nil), always_parens: T.unsafe(nil)); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/share/stringifies_call.rb#13
  sig do
    params(
      calls: T::Array[::Mocktail::Call],
      nonzero_message: ::String,
      zero_message: ::String,
      anonymous_blocks: T::Boolean,
      always_parens: T::Boolean
    ).returns(::String)
  end
  def stringify_multiple(calls, nonzero_message:, zero_message:, anonymous_blocks: T.unsafe(nil), always_parens: T.unsafe(nil)); end

  private

  # source://mocktail//lib/mocktail/sorbet/mocktail/share/stringifies_call.rb#47
  sig { params(args: T::Array[::Object]).returns(T.nilable(::String)) }
  def argify(args); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/share/stringifies_call.rb#30
  sig { params(call: ::Mocktail::Call, parens: T::Boolean).returns(T.nilable(::String)) }
  def args_to_s(call, parens: T.unsafe(nil)); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/share/stringifies_call.rb#65
  sig { params(block: T.nilable(::Proc), anonymous: T::Boolean).returns(T.nilable(::String)) }
  def blockify(block, anonymous:); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/share/stringifies_call.rb#53
  sig { params(kwargs: T::Hash[::Symbol, ::Object]).returns(T.nilable(::String)) }
  def kwargify(kwargs); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/share/stringifies_call.rb#59
  sig { params(block: T.nilable(::Proc)).returns(T.nilable(::String)) }
  def lambdafy(block); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/share/stringifies_call.rb#76
  sig { params(block: ::Proc).returns(::String) }
  def source_locationify(block); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/share/stringifies_call.rb#81
  sig { params(path: ::String).returns(::String) }
  def strip_pwd(path); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/share/stringifies_method_name.rb#4
class Mocktail::StringifiesMethodName
  # source://mocktail//lib/mocktail/sorbet/mocktail/share/stringifies_method_name.rb#8
  sig { params(call: ::Mocktail::Call).returns(::String) }
  def stringify(call); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/stringifies_method_signature.rb#4
class Mocktail::StringifiesMethodSignature
  # source://mocktail//lib/mocktail/sorbet/mocktail/stringifies_method_signature.rb#8
  sig { params(signature: ::Mocktail::Signature).returns(::String) }
  def stringify(signature); end

  private

  # source://mocktail//lib/mocktail/sorbet/mocktail/stringifies_method_signature.rb#45
  sig { params(signature: ::Mocktail::Signature).returns(::String) }
  def block(signature); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/stringifies_method_signature.rb#32
  sig { params(signature: ::Mocktail::Signature).returns(T.nilable(::String)) }
  def keyword(signature); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/stringifies_method_signature.rb#19
  sig { params(signature: ::Mocktail::Signature).returns(T.nilable(::String)) }
  def positional(signature); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/stubbing.rb#4
class Mocktail::Stubbing < ::T::Struct
  extend T::Generic

  MethodReturnType = type_member

  const :demonstration, T.proc.params(matchers: ::Mocktail::MatcherPresentation).returns(MethodReturnType)
  const :demo_config, ::Mocktail::DemoConfig
  prop :satisfaction_count, ::Integer, default: T.unsafe(nil)
  const :recording, ::Mocktail::Call
  prop :effect, T.nilable(T.proc.params(call: ::Mocktail::Call).returns(MethodReturnType))

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/stubbing.rb#16
  sig { void }
  def satisfied!; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/stubbing.rb#21
  sig { params(block: T.proc.params(call: ::Mocktail::Call).returns(MethodReturnType)).void }
  def with(&block); end

  class << self
    # source://mocktail//lib/mocktail/sorbet/mocktail/value/double_data.rb#13
    # source://sorbet-runtime/0.5.10983/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/typed.rb#4
Mocktail::TYPED = T.let(T.unsafe(nil), TrueClass)

# The TopShelf is where we keep all the more global, dangerous state.
# In particular, this is where Mocktail manages state related to singleton
# method replacements carried out with Mocktail.replace(ClassOrModule)
#
# source://mocktail//lib/mocktail/sorbet/mocktail/value/top_shelf.rb#7
# The TopShelf is where we keep all the more global, dangerous state.
# In particular, this is where Mocktail manages state related to singleton
class Mocktail::TopShelf
  # source://mocktail//lib/mocktail/sorbet/mocktail/value/top_shelf.rb#19
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/top_shelf.rb#50
  sig { params(type: T.any(::Module, T::Class[T.anything])).returns(T::Boolean) }
  def new_replaced?(type); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/top_shelf.rb#60
  sig { params(type: T::Class[T.anything]).returns(T::Boolean) }
  def of_next_registered?(type); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/top_shelf.rb#45
  sig { params(type: T.any(::Module, T::Class[T.anything])).void }
  def register_new_replacement!(type); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/top_shelf.rb#55
  sig { params(type: T::Class[T.anything]).void }
  def register_of_next_replacement!(type); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/top_shelf.rb#70
  sig { params(type: T.any(::Module, T::Class[T.anything])).void }
  def register_singleton_method_replacement!(type); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/top_shelf.rb#40
  sig { void }
  def reset_current_thread!; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/top_shelf.rb#75
  sig { params(type: T.any(::Module, T::Class[T.anything])).returns(T::Boolean) }
  def singleton_methods_replaced?(type); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/top_shelf.rb#26
  sig { params(type: T.any(::Module, T::Class[T.anything])).returns(::Mocktail::TypeReplacement) }
  def type_replacement_for(type); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/top_shelf.rb#33
  sig { params(type: T.any(::Module, T::Class[T.anything])).returns(T.nilable(::Mocktail::TypeReplacement)) }
  def type_replacement_if_exists_for(type); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/top_shelf.rb#65
  sig { params(type: T::Class[T.anything]).void }
  def unregister_of_next_replacement!(type); end

  class << self
    # source://mocktail//lib/mocktail/sorbet/mocktail/value/top_shelf.rb#11
    sig { returns(::Mocktail::TopShelf) }
    def instance; end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/simulates_argument_error/transforms_params.rb#6
class Mocktail::TransformsParams
  # source://mocktail//lib/mocktail/sorbet/mocktail/simulates_argument_error/transforms_params.rb#10
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/simulates_argument_error/transforms_params.rb#15
  sig do
    params(
      dry_call: ::Mocktail::Call,
      params: T.nilable(T::Array[T::Array[::Symbol]])
    ).returns(::Mocktail::Signature)
  end
  def transform(dry_call, params: T.unsafe(nil)); end

  private

  # source://mocktail//lib/mocktail/sorbet/mocktail/simulates_argument_error/transforms_params.rb#48
  sig { params(params: T::Array[T::Array[::Symbol]]).returns(T::Array[T::Array[::Symbol]]) }
  def name_unnamed_params(params); end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/errors.rb#18
class Mocktail::TypeCheckingError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/type_replacement.rb#4
class Mocktail::TypeReplacement < ::T::Struct
  const :type, T.any(::Module, T::Class[T.anything])
  prop :original_methods, T.nilable(T::Array[::Method])
  prop :replacement_methods, T.nilable(T::Array[::Method])
  prop :original_new, T.nilable(::Method)
  prop :replacement_new, T.nilable(::Method)

  class << self
    # source://sorbet-runtime/0.5.10983/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/type_replacement_data.rb#4
class Mocktail::TypeReplacementData < ::T::Struct
  include ::Mocktail::ExplanationData

  const :type, T.any(::Module, T::Class[T.anything])
  const :replaced_method_names, T::Array[::Symbol]
  const :calls, T::Array[::Mocktail::Call]
  const :stubbings, T::Array[Mocktail::Stubbing[T.anything]]

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/type_replacement_data.rb#15
  sig { returns(T.any(::Module, T::Class[T.anything])) }
  def double; end

  class << self
    # source://sorbet-runtime/0.5.10983/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/errors.rb#6
class Mocktail::UnexpectedError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/unsatisfying_call.rb#4
class Mocktail::UnsatisfyingCall < ::T::Struct
  const :call, ::Mocktail::Call
  const :other_stubbings, T::Array[Mocktail::Stubbing[T.anything]]
  const :backtrace, T::Array[::String]

  class << self
    # source://sorbet-runtime/0.5.10983/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/value/unsatisfying_call_explanation.rb#4
class Mocktail::UnsatisfyingCallExplanation
  # source://mocktail//lib/mocktail/sorbet/mocktail/value/unsatisfying_call_explanation.rb#14
  sig { params(reference: ::Mocktail::UnsatisfyingCall, message: ::String).void }
  def initialize(reference, message); end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/unsatisfying_call_explanation.rb#11
  sig { returns(::String) }
  def message; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/unsatisfying_call_explanation.rb#8
  sig { returns(::Mocktail::UnsatisfyingCall) }
  def reference; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/value/unsatisfying_call_explanation.rb#20
  sig { returns(T.class_of(Mocktail::UnsatisfyingCallExplanation)) }
  def type; end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/errors.rb#8
class Mocktail::UnsupportedMocktail < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/sorbet/mocktail/version.rb#11
Mocktail::VERSION = T.let(T.unsafe(nil), String)

# source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/validates_arguments.rb#4
class Mocktail::ValidatesArguments
  # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/validates_arguments.rb#32
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/validates_arguments.rb#37
  sig { params(dry_call: ::Mocktail::Call).returns(::NilClass) }
  def validate(dry_call); end

  class << self
    # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/validates_arguments.rb#7
    sig { void }
    def disable!; end

    # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/validates_arguments.rb#17
    sig { returns(T::Boolean) }
    def disabled?; end

    # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/validates_arguments.rb#12
    sig { void }
    def enable!; end

    # source://mocktail//lib/mocktail/sorbet/mocktail/handles_dry_call/validates_arguments.rb#22
    sig { params(disable: T.nilable(T::Boolean), blk: T.proc.returns(T.anything)).void }
    def optional(disable, &blk); end
  end
end

# source://mocktail//lib/mocktail/sorbet/mocktail/errors.rb#16
class Mocktail::VerificationError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/sorbet/mocktail/verifies_call.rb#8
class Mocktail::VerifiesCall
  # source://mocktail//lib/mocktail/sorbet/mocktail/verifies_call.rb#12
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/sorbet/mocktail/verifies_call.rb#19
  sig do
    params(
      demo: T.proc.params(matchers: ::Mocktail::MatcherPresentation).void,
      demo_config: ::Mocktail::DemoConfig
    ).void
  end
  def verify(demo, demo_config); end

  private

  # source://mocktail//lib/mocktail/sorbet/mocktail/verifies_call.rb#32
  sig { params(verifiable_call_count: ::Integer, demo_config: ::Mocktail::DemoConfig).returns(T::Boolean) }
  def verification_satisfied?(verifiable_call_count, demo_config); end
end

# sorbet gem fails to export some of these constants, so we need to in order to
# pass static typecheck
module T
  module Private
    module Methods
      module MethodHooks; end

      class Signature
        sig { returns(T::Array[T::Array[Symbol]]) }
        def parameters; end
      end

      module SingletonMethodHooks; end
    end

    module RuntimeLevels
      class << self
        sig { returns(Symbol) }
        def default_checked_level; end
      end
    end
  end
end
